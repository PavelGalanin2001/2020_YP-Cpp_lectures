---

---

# Классы

```cpp
class monstr
{
    int health, ammo;
    public:
        monstr(int he = 100, int am = 10)
        {
            health = he;
            ammo = am;
        }
        void draw(int x, int y, int scale, int position);
        int get_health()
        {
            return health;
        }
        int get_ammo()
        {
            return ammo;
        }
};
```

В данном примере два скрытых поля, значение которых из вне можно получить только используя методы.

Изначально это может показаться искуственым усложнением разработки программ. Однака сама разработка программ становиться безопасной.

Методы класса имеют непосредственный доступ к его полям. Внутри метода можно объявлять объекты, указатели, ссылки, как своего так и других классов.

Как правило, если внутри класса записано только объявление, либо загоовок, то сам метод должен быть определён в другом месте программы с момощью операции доступа к области видимости.

Как применить операцию доступа

```cpp
void monstr::draw(int x, int y, int scale, int position)
{
    /*тело метода*/
}
```

Встроенные методы можно определить из вне класса с помощью дерективы inline.

```cpp
inline int mosntr::get_ammo()
{
    return ammo;
}
```

Методы можно перегружать - это является одним из примеров полиморфизма.

Методы можно объявлять константными либо статическами. Одновремено нельзя определять контантными и статическими.

В классе возможно разработать метод, имя которого будет совпадать с именем класса. Данный метод называется конструктором.

Конструктор называется автоматически при создании объекта класса и предназначен для инициализации объекта.

Что дает автоматическией вызов конструктора? Автоматический вызов конструктора поволяет избежать ситуации, которая может возникнуть при попытке использования не инициализированных переменных.

<div style="page-break-after: always;"></div>

# Объекты класов

Переменные типа данных класс обычно называют экземплярами класса - объектами.

Область видимости объектов экземпляра класса и его видимости зависит от его вида и место описания.

Описание объектов

```cpp
monstr Vasia; //Объект класса monstr с параметрами по умолчанию

monstr Super(200m 300); //Объект с явной инициализацией

monstr stado[100]; //Массив объектов с параметрами по умолчанию

monstr *beavis = new monstr(10); //Динамический объект(второй параметр задается по умолчанию)

monstr &butthead = Vasia; //Ссылка на объект
```

При создании любого экземпляра памяти всегда выделяется память.

Размер памяти всегда достаточен для хранения всех его полей.

Далее автоматически вызывается конструктор, который выполняет их инициализацию.

Методы класса не теражируются.

При выходе экземпляра класса из области действия он уничтожается и при этом автоматически происходит вызов деструктора.

//Доступ к интерфейсу класса аналогичен доступу к 

Доступ к открытым элементам экземпляра класса аналогичен тоступу полям структур.

Для доступа к открытым элементам экземпляра класса используется операцие точка при обращение к элементу имя объекта и операция стрелочка при обращении через указатель.

```cpp
объект.поле

указатель->поле

(*указатель).поле

объект.методы(параметры)

указатель->метод(параметры)

(*указатель).метод(параметры)
```

Обращение к открытому полю и вызов метода для массива объектов выглядит следующим образом:

```cpp
Имя_массива[индекс].поле
Имя_массива[индекс].метод(параметры)
```

Пример

```cpp
int n = Vasia.get_ammo();
stado[5].draw;
cout << beavis->get_health();
```

Так же возможно создать константный объект значение полей которого изменять запрещено. КОнстантному объекту допустимо применять только константные методы.

Пример

```cpp
class monstr
{
    int get_health() const
    {
        return health;
    }
}

const monstr DEad(0, 0); //Константный объект
cout << Dead.get_health();
```

Константный метод объявляется со словом const, которое будет размещено после списка параметров.

Не может изменять значения класса.

Может вызывать только константные мотоды, однако может вызывваться для любых не только константных объектов.

Обычно рекомендуют разрабатывать как константные методы, которые разрабатываются для получения значения полей.

<div style="page-break-after: always;"></div>

# Указатель this

Каждый объект (либо экземпляр класса) содержит свой экземпляр полей класса.

Реализованные методы в классе не занимают память и не дублируются для каждого объекта.

Единственный экземпляр метода используется всеми объектами совместно и поэтому не статический метод должен знать для какого объекта он вызван.

Каждый не статический метод помимо явно объявленых параметров имеет ещё один скрытый параметр.

Скрытый параметр - это константный указатель на объект для которого он вызван.

В языке программирования для нас константный указатель на объект обознается с зарезервированым словом this.

Когда имя параметра метода совпадают с именем поля класса, то доступ к полю выполняется через этот указатель.

Пример применения данного указателя

```cpp
monstr& the_best(monstr &M)
{
    if (health > M.health())
    {
        return this;
    }
}

...

monstr Vasia(50), Super(200); //Новый объект

//Best инициализируется значениями полей Super
monstr Best = Vasia.the_best(Super);
```

`monstr& the_best(monstr &M)` - это новый метод. Новый метод лучше разместь в паблике.

<div style="page-break-after: always;"></div>

# Конструкторы

Конструктор предназначены для инициаизации объекта. Конструктор всегда вызывается автоматически при создании объекта.

Конструктор обладает следующими свойствами

1. Конструктор не возвращает значение. Конструктор не возвращает даже void
2. Нельзя получать укзатель на конструктор.
3. Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализвации. В данном случае используется механизм перегрузки.
4. Конструктор, который можно вызвать без параметров именуется конструктором по умолчанию.
5. Параметры конструктора могут быть любого типа, кроме типа того же класса.
6. Можно задавать параметры конструктора по умолчанию. В этом случае их может содержать только один из конструкторов.
7. Если програмист не указал ни одного конструктора компилятор создаёт его автоматически, кроме случая, когда в классе содержаться константы и ссылки. Так как их необходимо инициализировать.
8. Конструкторы не наследуются.
9. По отношению к конструктору нельзя применять const, virtual и static.
10. Конструкторы глобальных объектов вызываються до вызова функции main
11. Локальные объекты создаются как только становяться активны области действия
12. Также конструктор запускается при создании временого объекта. Например, при передачи объекта из функции.

Вывод: всегда при объявлении объектов вызывается один из конструторов.

1-ая ситуация) при отсутсвии инициализирующего выражения в объявлении объекта вызывается конструктор по умолчанию.

2-ая ситуация) при инициализации объекта объектом тогоже типа вызывается конструктор копирования.

При инициализации полей вызывается один из явно определёных констукторо инициализации.

<u>Конструкторы инициализации</u> - это те конструторы, которым передаються параметры для инициализации полей объекта.

Конструкторы часто вызываються не явно для создания временых объектов. Такой вызов происходит в ледующих ситуациях

1. Инициализации
2. При выполнеии операции присваивания
3. Для задания значенгий по умолчанию.
4. При создании и инициализации массива
5. При создании динамических объектов.
6. При передачи параметров в функцию и возврате результатов по значению.

Конструктор вызывается в программе, если встретелись следующие конструкции:

```cpp
имя_класса имя_объекта [(список параметров)]; //Список параметров не должны быть пустым
имя_класса (список параметров); //Создается объект без имени (список может быть пустым)
имя_класса имя_объекта = выражение; //Создается объект без имени и копируется
```
