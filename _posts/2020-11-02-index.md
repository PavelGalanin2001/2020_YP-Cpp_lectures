---

---

# Перегрузка унарных операция

Унарная опреация может быть определена двумя способами
1. Как компонентная функция без параметров
2. Как глобальная (возможно дружественная функция с одним параметром)

Для первого случая выражение `@z` означает вызов `z.operator@();`

Во втором случае это означает вызов `operator@(Z);`

1. Унарные операции перегружаемые в рамках определённого класса могут перегружаться только через не статическую компонентную функцию без параметров. Вызываемый объект класса автоматически воспринимается как операнд.
2. Унарные операции перегружаемые вне области класса (как глобальные функции) должны иметь один параметр типа класса. Передаваемый через этот параметр объект воспринимается как операнд.

1. 
```cpp
тип_возвращаемого_значения operator знак_операции ()
```

2. 
```cpp
тип_возвращаемого_значения operator знак_операции (идентификатор_типа)
```

Пример

```cpp
class Person
{
    public:
        void operator ++()
        {
            ++age;
        }
    protected:
        int age;
        //...
};

int main()
{
    Person John;
    ++John;
    return 0;
}
```

второй случай

```cpp
class Person
{
    protected:
        int age;
        //...
        friend void operator ++ (Person&);
};

void operator ++ (Person& oB)
{
    ++oB.age;
}

int main()
{
    Person John;
    ++John;
    return 0;
}
```

## Перегрузка операции `++` и `--`

Унарные операции инкримента и декримента существует в вух формах: префиксной и постфиксной.

Префиксная форма определяется следующим образом

```
operator ++();
operator --();
```

Постфиксная определяется следующим образом

```
operator ++(int);
operator --(int);
```

Указания параметра int в постфиксной форме не специфицирует второй операнд, п используется только для отличия от префиксной формы.

Пример реализации префиксной и постфиксной формы операции `++`:

```cpp
class Person
{
    public:
        void operator ++()
        {
            ++age;
        }

        void operator++(int)
        {
            age++;
        }

    protected:
        int age;
};

int main()
{
    Person John;
    ++John;
    John++;

    return 0;
}
```

Перегрузка бинарных операторов

Пример перегрузки

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class String
{
    public:
        String(const char*);
        const char* operator +(const char* rvalue);
        void operator +=(const char* rvalue);
        void operator +=(String& rvalue);
        void print()
        {
            cout << data;
        }
        const char* get_data() {
            return data;
        }
    private:
        char data[256];
};

String::String(const char* str)
{
    strcpy(data, str);
}

void String::operator +=(const char* rvalue)
{
    strcat(data, rvalue);
}

void String::operator +=(String& rvalue)
{
    strcat(data, rvalue.get_data());
}

int main()
{
    String MyStr1 = "StringOne",
           MyStr2 = "StringTwo";

    MyStr1 += MyStr2;
    MyStr1.print();
    MyStr1 += "1111";
    return 0;
}
```

Console Out:

```
StringOneStringTwo
```

# Python

Интерпретированный язык программирования

Встроенные типы

Все данные в Python представлены объектами

Имена являются лишь сслыками на эти объекты и не несут нагрузку по декларации типа

Значение встроенных типов имеют специальную поддерку в синтаксисе языках.

Объекты могут быть не изменчивыми и изменчивыми.

## Встроеные типы
1. Специальные типы `None`, `NotImplemented`, `Ellipsis`

2.  Числа
- целые `int`
- целые произвольной `long`
- логические `bool`
- числа с плавающей точкой `float`
- комплексное число `complex`

3. Последовательности
- не изменчивые строка str, unicode строка, tuple
- изменчивые

4. Картедж
- изменчивые - список `list`
- не изменчивые

5. Отображения - словарь - `dict`

6. Объекты которые можно вызывать