|               |                             |
| ------------- | --------------------------- |
| Преподаватель | Мария Викторовна Хацкевич   |
| Студент       | Павел Иннокентьевич Галанин |

1. ...
2. Деструктор
3. Статические члены класса

<div style="page-break-after: always;"></div>

```cpp
//---- - --
monstr::monstr(int he, int am)
{
    health = he;
    ammo = am;
    skin = red;
    name = 0;
}
//---- -
monstr::monstr(color sk)
{
    switch(sk)
    {
    case red:
        health = 100;
        ammo = 10;
        skin = red;
        name = 0;
        break;
    case green:
        health = 100;
        ammo = 20;
        skin = green;
        name = 0;
        break;
    case blue:
        health = 100;
        ammo = 40;
        skin = blue;
        name = 0;
        break;
    }
}
```

Конструктор по умолчанию можно вызывать без параметров. На даном примере объекты класса можно инициализировать различными способами. Требуемый конструктор будет вызван в соотвествии со списком инициализации.

Конструктор копирования 

Конструктор копирования необходим для того, чтобы создавать реальную копию объекта, а не битовую форму. Например, мы передаём объект в функцию в виде параметра. Функция будет работать не с самим объектом, а с его побитывыми  копией. В конструкторе класса при создании объекта выделяется определённый объем памяти.

Деструктор объекта эту память освобождает. Указатель побитовой копии объекта будет хранить тот же адрес памти, что и оригинальный объект. И тогда при завершении работы функции и уничтожении побитовой копии объекта сработает деструктор, который обязательно высвободит память, которая была занята объектом оригиналом. В придачу при завершении работы программы деструктор сработает повторно и попытается ещё раз высвободить этот же объем памяти, что не избежно приведёт к ошибке. Та же учесть постигает и память выделеную для указателя объекта, если будет удаляться побитовая копия возвращаемого функцией значения объекта и побитовая копия при инициализации объекта класса другим объектам.

<u>Конструктор копирования</u> - это специальный вид конструктора, который получает в качестве единственного параметра указатель на объект тогоже класса.

```cpp
T::T(const T&)
{
    ...
    /* Тело конструктора */
}
```

Где T - имя класса.

Данный конструктор вызывается в тех случаях, когда новый объект создаётся путем копирования существуещего.

Конструктор копирования вызывается в следующих случаях

- при написании нового объекта с инициализацией другим объектам (например, когда мы в главной функции один объект класса инициализируем другим объектом класса)
- при передаче объекта в функцию по значению (объект передается в функцию по значению в качестве параметра)
- при возврате объекта из функции

Если программист не указал ни одного конструктора копирования, то он создаётся автоматические. Такой конструктор выполняет по элементное копирование полей. И если класс будет содержать указатели или ссылки в качестве своих полей, то в дальнейшем это вызовет ошибки по скольку копия и оригинал будут ссыаться на одну область памяти.

```cpp
monstr::monstr(const monst &M)
{
    if (M.name)
    {
        name = new char[strlen(M.name) + 1];
        strcpy(name, M.name);
    }
    else
    {
        name = 0;
    }

    health = MM.health;
    ammo = M.ammo;
    skin = M.skin;
}

monstr Vasia(blue);
monstr Super = Vasia;
// Работает конструктор копирования
monstr* m = new monstr("Ore");
monstr Green = *m;
// Работает конструктор копирования
```

<div style="page-break-after: always;"></div>

# Деструктор

**<u>Деструктор</u>** - это специальный метод класса, который служит для уничтожения элемента класса.

Чаще всего его используют тогда, когда в конструкторе, при создании объекта класса, динамически был выделен участок памяти и данную память необходимо высвободить.

Конструктор и деструктор объявляются в разделе `public`. ПРи объявлении конструктора тип данных возвращаемого значения не указывается в том числе и `void`. И деструктора тоже самое - тип данных возвращаемого значения отсутствует. Деструктору нельзя передавать параметры. Имя класса и имя конструктора индентичны. Имя деструктора индентично имени конструктора но без преставки `~` (тильда).

В классе допустимо несколько конструкторов.

В классе объявляется только один деструктор. Примеры:

```cpp
monstr::~monstr()
{
    delete [] name;
}
```

Деструктор можно вызвать явным образом путем указания полностью уточненного имени, например:

```cpp
monstr *m;
m->~monstr();
```

<!-- Пример который демострирует Работу  -->

```cpp
#include <iostream>

using namespace std;

class AB
{
private:
    int a;
    int b;
public:
```

Инерфейс класса

```cpp
    AB(int A, int B) //эти параметры мы передадим при создании объекта в main
    {
        a = A; //присвоим нашим элементам класса значения параметров
        b = B;
        cout << "Тут сработал конструктор, который принимает параметры: " << endl; //и здесь же их отобразим на экран
        cout << "a = " << a << endl;
        cout << "b = " << b << endl;
    }
```

```cpp
    void setAB()
    {
        cout << "Введите целое число a: ";
        cin >> a;
        cout << "Введите целое число b: ";
        cin >> b;
    }
```

```cpp
    void getAB()
    {
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
```

```cpp
    ~AB() // это дуструктор. не будем заставлять его чистить ... //дописать
    { 
        cout << "Тут сработал деструктор" << endl;
    }
```

```cpp
};

int main()
{
    setlocale(LC_ALL, "rus");
    AB obj1(100, 100); //передаём конструктору параметры
    obj1.setAB(); //присвоим новые значения переменным
    obj1.getAB(); //и выведем их на экран
    AB obj2(200, 200); //передадим конструктору параметры
}
```

```bash
Тут сработал конструктор, который принимает параметры:
a = 100
b = 100
Введите целое число a: 333
Введите целое число b: 333
a = 333
b = 333

Тут сработал конструктор, который принимает параметры:
a = 200
b = 200
Тут сработал деструктор
Тут сработал деструктор
```

<div style="page-break-after: always;"></div>

# Статические члены класса

Члены класса могут использоваться ключевым словом `static`.

Когда член класса объявляется как статический, тем самым компилятору даётся указание, что должна существовать только одна копия этого члена класса. Сколько бы объектов этого класса не создавалось бы. Статический член класса используется совместно всеми объектами данного класса.

Статические данные инициализируются нулями при создании первого объекта и другая инициализация не предусмотрена.

При объявлении статического члена данных класса этот член не определяеться. Место этого необходимо обеспечить для статического члена класса глобальное определение вне класса. Это осуществляеться путём нового объявления статической переменной. При этом используется оператор области видимости для того чтобы идентифицировать класс, которому принадлежит переменная. Это необходимо выполнять для того, чтобы по статическую переменную была выделена память.

```cpp
#include <iostream.h>

class counter
{
    static int count;
public:
    void setCount(int i)
    {
        count = i;
    }

    void getCount()
    {
        cout << count << ", ";
    }  
}
```

```cpp
int counter::count;

int main()
{
    counter a, b;
    a.getCount();
    b.getCount();
    a.setCount(10);
    a.getCount();
    b.getCount();
    return 0;
}
```

В данном примере статическая переменная `count` объявляется два раза:

- внутри класса
- ...

Далее она сразу же инициализиреться нулем.

Переменная `count` в памяти храниться только в единственном экземпляре и совместно используется объектами.

Также можно создавать статические функции члены. Статические функции члены не могут прямо ссылаться на не статические данные или не статические функции, объявленные в классе. Почему? Причиной тому являеться отсутствие для них указателя `this`, и поэтому нет способа узнать с какими именно не статическими данными работать. Например, создали два объекта класса, содержащие статическую функциию `S`. Если функция `F` потаеться получить доступ нестатической переменной `a` определённой этим классов, то как определеить какую именной копию переменной `a` следует использовать? В этом заключаеться причина того, что статические функции могут обращаться только к другим статическим функциям или статическим данным.

Статические функции не могут быть виртуальными. Они не могут объявляться с модификатором `const`.

Статическая функция может вызываться

1. с использованием объекта класса
2. с использованием имени класса и оператора области видимости

Важно помнить, что даже при вызове статической функции с использованием объекта, где не передаёться указатель `this`.
