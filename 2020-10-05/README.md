Статическая функция может вызываться с использованием объекта класса или использованием имени класса и оператора области видимости.

Пример:

```cpp
enum
{
    shared,
    in_use,
    lode d,
    unlocked
};

class access
{
    static enum access_t acs;
    ...
    public:
    static void set_access(enum access_t a)
    {
        acs = a;
    }

    static enum access_t get_access()
    {
        return acs;
    }
}

enum access_t access:: acs;

int main()
{
    access obj1, obj2;
    access::set_access(locked);
    ...
    if (obj1.getaccess() == unlcked)
    {
        access::set.access(in_use);
        cout << "Access resource";
    }
    else
    {
        cout << "locked out";
    }

    return 0;
}
```

Статические функции имеют прямой доступ только к другим статическим функциям или статическим данным в пределах ожного и тогоже класса.

```cpp
enum
{
    shared,
    in_use,
    lode d,
    unlocked
};

class access
{
    static enum access_t acs;
    int i;
    ...
    public:
    static void set_access(enum access_t a)
    {
        acs = a;
    }

    static enum access_t get_access()
    {
        i = 100; // тут ошибка
        return acs;
    }
}

enum access_t access:: acs;

int main()
{
    access obj1, obj2;
    access::set_access(locked);
    ...
    if (obj1.getaccess() == unlcked)
    {
        access::set.access(in_use);
        cout << "Access resource";
    }
    else
    {
        cout << "locked out";
    }

    return 0;
}
```

При первом знакомстве со статическими членами класса зачастую не понятно их назначение. Однако во многих случаях использования статических членов класса позволяе избежать глобальности.

<div style="page-break-after: always;"></div>

# Наследование виртуальной функции и полиморфизм.

С помощью наследования возможно разработать общий класс определяющий общие черты совокупности объектов. Данный класс может наследоваться другими более специфическими классами каждый из которых может добавить что-нибудь своё.

С помощью наследования поддерживаеться полиморфизм во время выполнения программы. С помощью полиморфизма реализуется принцип один интерфейс и множество методов.

Полиморфизм поддерживается

1. на этапе исполнения программы
2. на этапе компиляции

Пример на этапе компиляции - перегрузка оператора и функции

Пример наследования - на этапе выполнения

Перегрузка операторов и функции это очень полезная процедура.

Полиморфизм времени имполнения программы.

Пример: генерации производных классов и разработка виртуальных функций.

Класс, который наследуется другим классов называется базовым.

Класс выполняющий наследования - называется производным классов или потомком.

Спецификатор доступа при наследовании базового класса.

От того с каким спецификатором доступа объявляеться наследование базоваого класса зависит статус доступа членам производного класса.

```cpp
class имя_класса: доступ имя_класса
{
    ...
};
```

Таблица

| Доступ    | Спецификатор в базовом классе | Доступ в произв классе |
| --------- | ----------------------------- | ---------------------- |
| private   | private                       | нет                    |
|           | protected                     | private                |
|           | public                        | private                |
| protected | private                       | нет                    |
|           | protected                     | protected              |
|           | public                        | protected              |
| public    | private                       | нет                    |
|           | protected                     | public                 |
|           | public                        | public                 |

Доступ определяет каким способом наследуеться базовый класс. Спецификатор доступа может принимать три значения:
1. `private`
2. `public`
3. `protected`

Если спецификатор доступа опущен, то по умолчанию это `public`.

1-ое правило) Если спецификатор доступа принимает значение `public`, то все публичные и защищенные члена базового класса становяться публичными и защещеными членами производного класса.

class имя_класса: `доступ` имя_класса

2-ое правило) Если спецификатор доступа имеет значение `private` то все публичные и защищеные члены базового класса становятся частными членами производного класса.

3-ие правило) Если спецификатор доступа принимает значение `protected`, то все публичные и защищенные члены базового класса становятся защищеными членами произволного класса.

`protected` - это модификатор доступа который сигнализирует о том, что программист собирается применить наследование. В наследуемых классах он собирается унаследовать такие элементы, которые должны срабатывать как элементы `private`, но в отличии от `private` они размножаться по всем наследникам и каждый такое элемент будет соотвествовать только своему классу.

```cpp
class X
{
protected:
    int i;
    int j;

    void get_ij()
    {
        cout << "Ender ij";
        cin >> i >> j;
    }

    void put_ij()
    {
        cout << i << j;
    }
}

class Y: public X  //2) class Y: private X
{
    int k; //private по умолчанию

public:
    int get_k()
    {
        return k;
    }

    void make_k()
    {
        k = i * j;
    }
}

class Z: public Y
{
public:
    void f();
}

void Z::f()
{
    i = 2;
    j = 3;
}

int main()
{
    Y v, Z v2;

    v.get_ij();
    v.put_ij();
    v.make_k();
    cout << v.get_k();

    v2.f();
    v2.put_ij(); //2) не доступны i и j

    return 0;
}
```

Класс `Z` имеет доступ к `i` и `j` класса `X`.

Класс `Z` не имеет доступа к `k` класса `Y` (так как он является частным).

Если мы изменим статус `X` при объявлении `Y`, то в классу `Y` `i` и `j` будут преобразованы частным членам.

Класс Z В этом случае не будет иметь доступ к `i`, `j` и не будет иметь доступ к `get_ij()` и `put_ij()` так как они стали частными членами.

...стоит спецификатор доступа private и члены `i`, `j`, `get_ij()`, `put_ij()` становятся частными членами x и y и не наследуются `Z`

<div style="page-break-after: always;"></div>

# Множественное наследование

Один класс может наследовать атибуты двух и более классов одновременно. Для этого используется список базовых классов в котором базовые классы разделяются запятой.

Общий формат:

```cpp
class имя_производного_класса: доступ список_базовых_классов;

class имя_производного_класса: доступ базовый_класс_1, доступ базовый_класс_2;
```

```cpp
#include <iostream>
using namespace std;

class X
{
protected:
    int a;
public:
    X()
    {
        cout << "X";
        a = 10;
    }
};

class Y
{
protected:
    int b;
public:
    Y()
    {
        cout << "Y";
        b = 20;
    }
};

class Z: public X, public Y
{
public:
    Z()
    {
        cout << "Z"; 
    }
    int make_ab()
    {
        return a * b;
    }
};

int main()
{
    Z i;
    cout << i.make_ab();
    return 0;
}
```

Console:

```
XYZ200
```

Вывод происходит, так как происходит множественное наследование и содержит конструкторы по умолчанию.

<div style="page-break-after: always;"></div>
